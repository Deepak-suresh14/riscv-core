$date
	Sun Feb 14 20:22:55 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module rv32_soc_TB $end
$var reg 1 ! clock $end
$var reg 1 " reset $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 # o_data [31:0] $end
$var wire 1 $ mem_wr $end
$var wire 1 % mem_rd $end
$var wire 32 & i_data [31:0] $end
$var wire 32 ' PC [31:0] $end
$scope module core $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 ( writeBack $end
$var wire 5 ) writeBackRegId [4:0] $end
$var wire 1 * writeBackEn $end
$var wire 32 + regOut2 [31:0] $end
$var wire 32 , regOut1 [31:0] $end
$var wire 32 - in_data [31:0] $end
$var wire 32 . imm [31:0] $end
$var wire 1 / funcQual $end
$var wire 3 0 func3 [2:0] $end
$var wire 32 1 aluout [31:0] $end
$var wire 5 2 RegId2 [4:0] $end
$var wire 5 3 RegId1 [4:0] $end
$var wire 32 4 PCplus4 [31:0] $end
$var reg 32 5 PC [31:0] $end
$var reg 32 6 aluIn1 [31:0] $end
$var reg 32 7 aluIn2 [31:0] $end
$var reg 32 8 instr [31:0] $end
$var reg 1 % mem_rd $end
$var reg 1 $ mem_wr $end
$var reg 32 9 out_data [31:0] $end
$var reg 32 : out_mem_addr [31:0] $end
$var reg 5 ; state [4:0] $end
$var reg 32 < writeBackData [31:0] $end
$scope module ALU $end
$var wire 1 ! clk $end
$var wire 32 = in1 [31:0] $end
$var wire 32 > in2 [31:0] $end
$var wire 1 / opequal $end
$var wire 3 ? func3 [2:0] $end
$var reg 32 @ out [31:0] $end
$upscope $end
$scope module decoder $end
$var wire 1 A funcisshift $end
$var wire 32 B instr [31:0] $end
$var wire 5 C rs2 [4:0] $end
$var wire 5 D rs1 [4:0] $end
$var wire 5 E rd [4:0] $end
$var wire 3 F func3 [2:0] $end
$var reg 1 / funcQual $end
$var reg 32 G imm [31:0] $end
$var reg 1 * writeBackEn $end
$upscope $end
$scope module regs $end
$var wire 1 ! clock $end
$var wire 32 H data1 [31:0] $end
$var wire 32 I data2 [31:0] $end
$var wire 1 ( inEn $end
$var wire 5 J read1 [4:0] $end
$var wire 5 K read2 [4:0] $end
$var wire 32 L writedata [31:0] $end
$var wire 5 M writereg [4:0] $end
$var integer 32 N i [31:0] $end
$upscope $end
$upscope $end
$scope module ram $end
$var wire 32 O PC [31:0] $end
$var wire 1 ! clk $end
$var wire 32 P i_data [31:0] $end
$var wire 1 % rd $end
$var wire 1 $ wr $end
$var reg 32 Q o_data [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx Q
bx P
bx O
b100000 N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
xA
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
x/
bx .
bx -
bx ,
bx +
x*
bx )
x(
bx '
bx &
x%
x$
bx #
x"
0!
$end
#5000
b100 4
b0 5
0%
0$
b1 ;
1"
1!
#10000
0"
0!
#15000
1%
b0 '
b0 :
b0 O
b10 ;
1!
#20000
0!
#25000
b1000001000000110110011 &
b1000001000000110110011 -
b1000001000000110110011 Q
0%
b100 ;
1!
#30000
0!
#35000
0A
0/
1(
1*
b11 )
b11 E
b11 M
b101 ,
b101 H
b1 3
b1 D
b1 J
b11 +
b11 I
b10 2
b10 C
b10 K
b0 0
b0 ?
b0 F
b1000001000000110110011 8
b1000001000000110110011 B
b1000 ;
1!
#40000
0!
#45000
b11 7
b11 >
b101 6
b101 =
b1000 4
b100 5
b1 ;
1!
#50000
0!
#55000
1%
b100 '
b100 :
b100 O
b10 ;
b1000 1
b1000 @
1!
#60000
0!
#65000
b1000000001000001000000110110011 &
b1000000001000001000000110110011 -
b1000000001000001000000110110011 Q
0%
b100 ;
1!
#70000
0!
#75000
1/
b1000000001000001000000110110011 8
b1000000001000001000000110110011 B
b1000 ;
1!
#80000
0!
#85000
b1000 <
b1000 L
b1100 4
b1000 5
b1 ;
b10 1
b10 @
1!
#90000
0!
#95000
b100000 N
1%
b1000 '
b1000 :
b1000 O
b10 ;
1!
#100000
0!
#105000
bx &
bx -
bx Q
0%
b100 ;
1!
#110000
0!
